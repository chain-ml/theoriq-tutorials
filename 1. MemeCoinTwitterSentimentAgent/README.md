# Memecoin Twitter Sentiment Agent

Welcome to the **Memecoin Twitter Sentiment Agent** tutorial! This guide will walk you through building a simple agent using Theoriq's SDK. The goal is to help you understand the foundational components and functionality of the Theoriq SDK by creating a real-world use case.

## Objectives

By following this tutorial, you will:

- Learn how to set up and configure Theoriq's SDK.
- Understand the main building blocks of the SDK.
- Build an agent that fetches latest tweets related to memecoins and analyzes their sentiment.



## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Keypair Generation](#keypair-generation)
3. [Running and testing the agent](#running-the-agent)
4. [Local Test vs. Registration on Theoriq Protocol](#local-test-vs-registration-on-theoriq-protocol)
5. [SDK Request and Response Bodies](#sdk-request-and-response-bodies)


## Prerequisites

Before starting, ensure you have the following:

- Basic familiarity with Python
- A Twitter Developer account with API access
- OpenAI API Key
- Python 3.10 or later installed.


## Keypair Generation

To register an agent on the Theoriq protocol, as well as signing the biscuits, developers need to generate keypairs for each agent. In order to do so, please refer to the [generate private key](https://github.com/chain-ml/theoriq-agent-sdk/tree/main/scripts) script in the Theoriq SDK.



## Run and Test

1. Create a `.env` file according to the `.env.example` file.
2. Create a local python environment using `conda` or `venv`.
3. Install all the required packages

``` shell
pip install -r requirements.txt
```

4. Run the agent by

``` shell
python src/app.py
```

5. Use [http/test.http](http/test.http) to send http requests to `http://localhost:5050/api/v1alpha1/execute`


## Local Test vs. Registration on Theoriq Protocol

To **set up an agent locally**, the following variables need to be set in the `.env` file:
``` shell
THEORIQ_SECURED = false
THEORIQ_PUBLIC_KEY = CHANGEME
THEORIQ_PRIVATE_KEY = CHANGEME
```

The keyapirs **THEORIQ_PUBLIC_KEY** and **THEORIQ_PRIVATE_KEY** can be generated by following the [generate private key](https://github.com/chain-ml/theoriq-agent-sdk/tree/main/scripts) script in the Theoriq SDK.

However, these variables **SHOULD NOT** exist in the env variables when the agent is ready to be registered on Theoriq Protocol.

## SDK Request and Response Bodies

The main endpoint of this application is `/api/v1alpha1/execute`, that is defined in [src/routes/twitter_sentiments.py](src/routes/twitter_sentiments.py). Since Theoriq protocol supports chat histroy, as well as agent-to-agent communications, the first step is to extract the last message where `block_type` is not `router`

```python
from theoriq.schemas import ExecuteRequestBody

#req: ExecuteRequestBody
last_block = req.last_item_predicate(
            lambda item: item.blocks[0].block_type != "router"
        ).blocks[0]

memecoin = last_block.data.text
```

As we will explain in future tutorials, the request can contain multiple blocks, each with different source types (e.g. `user`, `router`, `agent`), as well as different data types (`text`, `custom`, etc). In this specific example, the incoming message is from a `user` with type `text`. We can see that in the sample request in the [http/test.http](http/test.http)

```python
POST {{host}}/api/v1alpha1/execute
Content-Type: application/json
Authorization: Bearer {{token}}

{
    "dialog": {
        "items": [
            {
                "timestamp": "2024-08-07T00:00:00.000000+00:00",
                "sourceType": "user",
                "source": "0x02",
                "blocks": [
                    {
                        "data": {
                            "text": "doge"
                        },
                        "type": "text"
                    }
                ]
            }
        ]
    }
}
```

When this request is sent, the following will be the agent's response:

```python
{
    "timestamp": "2024-11-26T13:27:40.112896+00:00",
    "sourceType": "agent",
    "source": "0x4ee0b4ec6055d573fb5d11d7ea93fa4825e3bfbdf235490dc70871bda1cf8a5b",
    "blocks": [
        {
        "data": {
            "text": "Based on latest conversations on X (formerly Twitter), [REST OF THE ANSWER]"
        },
        "type": "text"
        }
    ]
}
```

If user wants to ask a another question, the protocol builds the following request and sends it to the agent:

```python
{
    "dialog": {
        "items": [
            {
                "timestamp": "2024-08-07T00:00:00.000000+00:00",
                "sourceType": "user",
                "source": "0x02",
                "blocks": [
                    {
                        "data": {
                            "text": "doge"
                        },
                        "type": "text"
                    }
                ]
            },
            {
                "timestamp": "2024-11-26T13:27:40.112896+00:00",
                "sourceType": "agent",
                "source": "0x4ee0b4ec6055d573fb5d11d7ea93fa4825e3bfbdf235490dc70871bda1cf8a5b",
                "blocks": [
                    {
                    "data": {
                        "text": "Based on latest conversations on X (formerly Twitter), [REST OF THE ANSWER]"
                    },
                    "type": "text"
                    }
                ]
            },
            {
                "timestamp": "2024-11-26T13:29:40.112896+00:00",
                "sourceType": "user",
                "source": "0x02",
                "blocks": [
                    {
                        "data": {
                            "text": "btc"
                        },
                        "type": "text"
                    }
                ]
            },
        ]
    }
}
```

Since this agent doesn't support follow up questions, we only filter for the last request coming from non-router block.